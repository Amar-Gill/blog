---
layout: "@/layouts/BlogPost"
title: Custom Controls in a React Leaflet map
publishDate: 13 May 2023
description: Create a map with custom control widgets in a React map using React Leaflet
tags: ["react", "leaflet", "gis"]
draft: false
---

import LeafletMap from "src/components/LeafletMap.astro";

#### TLDR

TODO
- link to leaflet package
- link to react-leaflet package

### Getting Started

Let's add a standard map to our React app using the `react-leaflet` package. Begin by adding the dependencies to your React app.

```bash
npm i leaflet react-leaflet
npm i -D @types/leaflet @types/react-leaflet
```

We require the css for the leaflet package to be loaded. Add this `<link>` tag to the `<head>` of your page:

```tsx
<link
  rel="stylesheet"
  href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css"
  integrity="sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A=="
  crossOrigin=""
/>
```

With that in place let's create a basic `Map.tsx` component:

```tsx
// Map.tsx
import { MapContainer, Marker, Popup, TileLayer } from "react-leaflet";

const Map = () => {
  return (
    <MapContainer className="h-80" center={[51.505, -0.09]} zoom={13}>
      <TileLayer
        attribution='&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
      />
      <Marker position={[51.505, -0.09]}>
        <Popup>
          A pretty CSS3 popup. <br /> Easily customizable.
        </Popup>
      </Marker>
    </MapContainer>
  );
};

export default Map;
```

This gives us a basic leaflet map centered on London, England. It comes with a zoom control element and click and drag functionality. We also added a map marker that displays a pop up when clicked.

Make sure to set a height on the component. In this example I styled it with Tailwind CSS: `classname="h-80"`.

<LeafletMap showStaticMarker={true} />

### Creating our Custom Control

Now lets add an arbitrary html element as a control overlay to the leaflet map instance. A leaflet control is an instance of the `Control` class with the additional `onAdd` and `onRemove` methods. The `Control.extend` method returns a class that implements the leaflet `Control` type:

```tsx
// CustomControl.tsx
import { Control, DomUtil } from "leaflet";
import { useMap } from "react-leaflet";
import { useEffect } from "react";

export const LeafletCustomControl = () => {
  const mapContainer = useMap();

  const CustomControl = Control.extend({
    options: {
      position: "topright",
    },
    onAdd: function () {
      const el = DomUtil.create("div");

      el.className = "h-16 w-16 bg-pink-600";

      el.onclick = function () {
        alert("Hello from a custom Leaflet control!");
      };

      return el;
    },
    onRemove: function () {
      return;
    },
  });

  const customControl = new CustomControl();

  useEffect(() => {
    mapContainer.addControl(customControl);
  }, []);

  return null;
};
```

With some basic css styling, we will see a pink square in the top right corner of the map, with a click event handler. Add it as a child component of `<MapContainer>` to see the custom control element:

```tsx
// Map.tsx
<MapContainer>
  <TileLayer />
  <CustomControl />
</MapContainer>
```
<LeafletMap showBasicControl={true}/>

Here is the core concept on adding custom leaflet controls in React. The `useMap` hook returns the `<MapContainer>` reference of the child component. We instantiate an instance of our custom control and use the `addControl` method to add it as a control inside a `useEffect` hook. The React component itself returns `null`.

This is handy so all control functionality remains encapsulated inside the `Map.tsx` component. More importantly, the ui element will be rendered on top of the map tiles, which makes for an intuitive map control ux.

### The Geoapify Address Search

Let's make something useful now. In this example we will add a text input control that allows us to look up an address, and have the map set it's view to the location.

We will leverage the [Geoapify]() api for the address look up functionality. It has a generous request limit of 3000 api calls daily for the free tier, which is handy for prototyping. Geoapify also has a handy [address search npm package]() which makes it easy to create the input element with all styling and interactivity we need for the component, including making api calls to the Geoapify api.

Note: there is a separate [npm package for a react component]() that wraps address search functionality and exposes it as a react component. We will **not** be using the react package, because only native DOM elements can be added as a custom control onto a Leaflet map instance. As shown in the previous example, we returned an element which implements the `HTMLDivElement` type.

Before we proceed, you will need to visit the [geoapify]() platform and register so you can obtain an api key.

Next, install the package for the address search element:

```bash
npm i @geoapify/geocoder-autocomplete
```

Import the stylesheet into your `globals.css` file:

```css
@import "~@geoapify/geocoder-autocomplete/styles/minimal.css";
```

Let's modify the `<AddressSearch />` as follows:

```tsx
import { GeocoderAutocomplete } from "@geoapify/geocoder-autocomplete";
import { Control, DomUtil } from "leaflet";
import { useMap } from "react-leaflet";
import { useEffect } from "react";

export const AddressSearch = () => {
  const mapContainer = useMap();

  const SearchControl = Control.extend({
    options: {
      position: "topright",
    },
    onAdd: function (map: Map) {
      const el = DomUtil.create("div");

      el.className = "relative minimal";

      el.addEventListener("click", (e) => {
        e.stopPropagation();
      });

      el.addEventListener("dblclick", (e) => {
        e.stopPropagation();
      });

      const autocomplete = new GeocoderAutocomplete(el, `${process.env.NEXT_PUBLIC_GEOAPIFY}`, {
        placeholder: "Enter an address",
      });

      autocomplete.on("select", (location) => {
        map.setView(newPosition, map.getZoom());
      });

      autocomplete.on("suggestions", (suggestions) => {
        return;
      });

      return el;
    },
    onRemove: function (map: Map) {
      return;
    },
  });

  const searchControl = new SearchControl();

  useEffect(() => {
    mapContainer.addControl(searchControl);
  }, []);

  return null;
};
```

The `GeocoderAutocomplete` class accepts as arguments an html element, the api key, and some optional configurations. That line of code will add the search input element as a child of the parent `<div>` element denoted by `el`.

The autocomplete class exposes methods to attach event listeners to the input element. A list of events specific to the search field can be found here LINK. For this example we will make use of the `select` and `suggestions` events. The select event is triggered when one of the suggestions from the dropdown list of matching addresses / locations is clicked on. The callback function used for the `select` event can act as a closure, since the callback function of onAdd takes in the `map` instance as a parameter. We can call the leaflet setView method to move the map to the new coordinates.

Note: information returned from matching the text in the input fields counts toward the free API credits.

The npm package ships with their own styles. Refer to them here LINK.

Some notes on the event listeners added to the element:

- the `click` and `dblclick` event listeners call the `stopPropogation` method so when a user clicks or double clicks on the input field, the map tile behind the control element does not receice a click event and therefore trigger any other event listeners you set for the map tiles.

So when we return `el` from `onAdd`, we get the fully functional address search input element as a map control.

### Optimization

something something production, experienced react devs.

Let's wrap the expensive operations of creating dom elements and adding event listeners with the `useMemo` hook. We can return the instance of the `SearchControl` class from the hook, so that it is available in our `useEffect` hook:

```tsx
export const AddressSearch = () => {
  const mapContainer = useMap();

  const searchControl = useMemo(() => {
    const SearchControl = Control.extend({
      options: {
        position: "topright",
      },
      onAdd: function (map: Map) {
        const el = DomUtil.create("div");

        el.className = "relative minimal round-borders";

        el.addEventListener("click", (e) => {
          e.stopPropagation();
        });

        el.addEventListener("dblclick", (e) => {
          e.stopPropagation();
        });

        const autocomplete = new GeocoderAutocomplete(el, `${process.env.NEXT_PUBLIC_GEOAPIFY}`, {
          placeholder: "Enter an address",
        });

        autocomplete.on("select", (location) => {
          map.setView(newPosition, map.getZoom());
        });

        autocomplete.on("suggestions", (suggestions) => {
          return;
        });

        return el;
      },
      onRemove: function (map: Map) {
        return;
      },
    });

    return new SearchControl();
  }, [setPosition]);

  useEffect(() => {
    mapContainer.addControl(searchControl);
  }, [mapContainer, searchControl]);

  return null;
};
```
